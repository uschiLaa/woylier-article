---
title: "Frame to frame interpolation for high-dimensional data visualisation using the woylier package"
date: "2023-09-15"
abstract: >
  The woylier package implements tour interpolation paths between frames using Givens rotations. This provides an alternative to the geodesic interpolation between planes currently available in the tourr package. Tours are used to visualise high-dimensional data and models, to detect clustering, anomalies and non-linear relationships. Frame-to-frame interpolation can be useful for projection pursuit guided tours when the index is not rotationally invariant. It also provides a way to specifically reach a given target frame. We demonstrate the method for exploring non-linear relationships between currency cross-rates.
author:  
  # see ?rjournal_article for more information
  - name: Zoljargal Batsaikhan
    affiliation: Monash University
    address:
    - Department of Econometrics and Business Statistics
    - Clayton, VIC, Australia
    url: https://github.com/zolabat
    orcid: 0009-0005-0055-1448
    email:  zoljargal11@gmail.com
  - name: Dianne Cook
    url: http://www.dicook.org
    email: dicook@monash.edu
    orcid: 0000-0002-3813-7155
    affiliation: Monash University
    address:
    - Department of Econometrics and Business Statistics
    - Clayton, VIC, Australia
  - name: Ursula Laa
    url: https://uschilaa.github.io
    email: ursula.laa@boku.ac.at
    orcid: 0000-0002-0249-6439
    affiliation: BOKU University
    address:
    - Institute of Statistics
    - Vienna, Austria
type: package
output: 
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: woylier-article.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)
```

```{r load}
library(tourr)
library(tidyverse)
library(woylier)
library(geozoo)
library(ggplot2)
library(patchwork)
library(gganimate)
library(GGally)
library(corrplot)
library(kableExtra)
```

# Introduction

When data has up to three variables, visualization is relatively intuitive, while with more than three variables, we face the challenge of visualizing high dimensions on 2D displays. This issue was tackled by the *grand tour* [@asimov_1985] which can be used to view data in more than three dimensions using linear projections. It is based on the idea of rotations of a lower-dimensional projection in high-dimensional space. The grand tour allows users to see dynamic low-dimensional (typically 2D) projections of higher dimensional space. Originally, Asimov's grand tour presents the viewer with an automatic movie of projections with no user control. Since then new work has added interactivity to the tour, giving more control to users [@buja_cook_asimov_hurley_2005]. New variations include the manual [@cook_manual_1997] or radial tour [@mmtour], little tour, guided tour [@grandtour1995], local tour, and planned tour. These are different ways of selecting the sequence of projection bases for the tour, for an overview see @tourrev.

The guided tour combines projection pursuit with the grand tour and it is implemented in the \CRANpkg{tourr} package [@tourr]. Projection pursuit is a procedure used to locate the projection of high-to-low dimensional space that should expose the most interesting feature of data, originally proposed in @kruskal_1969. It involves defining a criterion of interest, a numerical objective function that indicates the interestingness of each projection, and an optimization for selecting planes with increasing values of the function. In the literature, a number of such criteria have been developed based on clustering, spread, and outliers. 

A tour path is a sequence of projections and we use an interpolation to produce small steps simulating a smooth movement. The current implementation of tour in \CRANpkg{tourr} package uses geodesic interpolation between planes. The geodesic interpolation path is the locally shortest path between planes with no within-plane spin (see @Buja2004TheoryOD for more details). As a result, the rendered target plane could be a within-plane rotation of the target plane originally specified. This is not a problem when the structure we are looking for can be identified from any rotation. However, even simple associations in 2D, such as the calculated correlation between variables, can be very different when the basis is rotated.

Most projection pursuit indexes, particularly those provided by the \CRANpkg{tourr} are rotationally invariant. However, there are some projection pursuit index where the orientation of frames does matter. One example is the splines index proposed by @Grimm2016. The splines index computes a spline model for the two variables in a projection, in order to measure non-linear association. It can be useful to detect non-linear relationships in high-dimensional data. However, its value will change substantially if the projection is rotated within the plane [@pp]. The procedure in @Grimm2016 was less affected by the orientation because it considered only pairs of variables, and it selects the maximum value found when exchanging which variable is considered as predictor and response variable.

Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:splines2d-static)', '\\@ref(fig:splines2d-static)'))` illustrates the rotational invariance problem for a modified spline2D index, where we always consider the horizontal direction as the predictor variable, and the vertical direction as the response. Thus, our modified index computes the splines on one orientation, exaggerating the rotational variability. The example data was simulated to follow a sine curve and the modified splines index is calculated on different within-plane rotations of the data. Although they have the same structure, the index values vary greatly. 

The lack of rotation invariance of the splines index raises complications in the optimisation process in the projection-pursuit guided tour as available in the \CRANpkg{tourr}. Fixing this is the motivation of this work. The goal with the frame-to-frame interpolation is that optimisation would find the best within-plane rotation, and thus appropriately optimize the index. 

```{r splines2d-static, out.width = "100%", fig.width = 9, fig.height = 4.5, layout = "l-body", fig.cap="The impact of rotation on a spline index that is NOT rotation invariant. The index value for different within-plane rotations take very different values: (a) original projection has maximum index value of 1.00, (b) axes rotated 45$^o$ drops index value to 0.83, (c) axes rotated 60$^o$ drops index to a very low 0.26. Geodesic interpolation between planes will have difficulty finding the maximum of an index like this because it is focused only on the projection plane, not the frame defining the plane.", fig.alt = "Three side-by-side scatterplots. The left side plot shows two variables, V5, V6, with a sine curve. The index value is the maximum of 1. The middle plot shows the two variables rotated 45 degrees clock-wise, and the calculated index value is 0.83. The right-side plot is rotated 60 degrees, and the calculated index value is 0.26."}
data("sine_curve")

# modified the splines2d
new_splines2d <- function ()
{
  function(mat) {
    mat <- as.data.frame(mat)
    colnames(mat) <- c("x", "y")
    kx <- ifelse(length(unique(mat$x[!is.na(mat$x)])) < 20,
                 3, 10)
    mgam1 <- mgcv::gam(y ~ s(x, bs = "cr", k = kx), data = mat)
    measure <- 1 - var(residuals(mgam1), na.rm = T)/var(mat$y, na.rm = T)
    return(measure)
  }
}
mat <- data.frame(sine_curve[,5:6])
mat_idx <- round(new_splines2d()(mat), 2)
rot1 <- matrix(c(cos(pi/4), sin(pi/4), 
                -sin(pi/4), cos(pi/4)),
              ncol=2, byrow=T)
mat_rot1 <- data.frame(x = rot1[1,1] * sine_curve$V5 + 
                          rot1[1,2] * sine_curve$V6,
                      y = rot1[2,1] * sine_curve$V5 + 
                           rot1[2,2] * sine_curve$V6)
mat_rot1_idx <- round(new_splines2d()(mat_rot1), 2)
rot2 <- matrix(c(cos(pi/3), sin(pi/3), 
                -sin(pi/3), cos(pi/3)),
              ncol=2, byrow=T)
mat_rot2 <- data.frame(x = rot2[1,1] * sine_curve$V5 + 
                          rot2[1,2] * sine_curve$V6,
                      y = rot2[2,1] * sine_curve$V5 + 
                           rot2[2,2] * sine_curve$V6)
mat_rot2_idx <- round(new_splines2d()(mat_rot2), 2)

p1 <- ggplot(mat, aes(x=V5, y=V6)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=c(1,0), V6=c(0,1)), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=c(1,0), V6=c(0,1), label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("a. 0 deg: ", mat_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p2 <- ggplot(mat_rot1, aes(x=x, y=y)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=rot1[1,], V6=rot1[2,]), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=rot1[1,], V6=rot1[2,], label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("b. 45 deg: ", mat_rot1_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p3 <- ggplot(mat_rot2, aes(x=x, y=y)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=rot2[1,], V6=rot2[2,]), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=rot2[1,], V6=rot2[2,], label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("c. 60 deg: ", mat_rot2_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p1+p2+p3
```

A few alternatives to geodesic interpolation were proposed by @buja_cook_asimov_hurley_2005 including the decomposition of orthogonal matrices, Givens decomposition, and Householder decomposition. The purpose of the **woylier** package is to implement the Givens paths method in R. This algorithm adapts the Given's matrix decomposition technique which allows the interpolation to be between frames rather than planes.

This article is structured as follows. The next section provides the theoretical framework of the Givens interpolation method followed by a section about the implementation in R. The method is applied to search for nonlinear associations between currency cross-rates.  

# Background

The tour method of visualization is animated high-to-low dimensional data rotation that is a movie, one-parameter (time) family of static projections. Algorithms for such dynamic projections @buja_cook_asimov_hurley_2005 are based on the idea of smoothly interpolating a discrete sequence of projections. 

The topic of this article is the construction of paths of projections. Interpolation of paths of projection can be compared to connecting line segments that interpolate points in Euclidean space. Interpolation acts as a bridge between continuous animation and discrete choice of sequences of projections. 

**The interpolating paths of plane versus frames**

Current implementation of \CRANpkg{tourr} package is locally shortest (geodesic) interpolation of planes. The pitfall of this interpolation method is that it does not account for rotation variability. Therefore, the interpolation of frames is required when the orientation of projection matters. If the rendering on a frame and on the rotated version of the frame yields the same visual scenes, it means the orientation does not matter. 

The orientation of frames could be important when non-linear projection pursuit function is used in guided tour. An illustration of such cases are shown in Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:dogs)', '\\@ref(fig:dogs)'))`.

```{r dogs, echo=FALSE, out.width="45%", fig.align = "center", fig.show='hold', fig.cap="Plane to plane interpolation (left) and Frame to frame interpolation (right). We used dog index for illustration purposes. For some non-linear index orientation of data could affect the index."}
knitr::include_graphics(
  c("plane.png",
    "frame.png"))
```

Before continuing with the interpolation algorithms, we need to define the notations. 

- Let the $p$ be the dimension of original data and $d$ be the dimension onto which the data is being projected. 

- A frame $F$ is defined as $p\times d$ matrix with pairwise orthogonal columns of unit length that satisfies, where $I_d$ is the identity matrix in d dimensions. 

$$F^TF = I_d$$ 

- Paths of projections are given by continuous one-parameter families $F(t)$ where $t\in [a, z]$ interval representing time. We denote the starting frame by $F_a = F(a)$ and target frame by $F_z = F(z)$. Usually, $F_z$ is selected target basis that has chosen via various methods. While grand tour chooses target frames randomly, guided tour chooses the target plane by optimizing the projection pursuit index. Interpolation methods are used to move from $F_a$ to $F_z$.

- $B$ is preprojection basis of $F_a$ and $F_z$.

**Preprojection algorithm**

In order to make the interpolation algorithm simple, we need to carry out "preprojection" step. 
The purpose of preprojection is to limit data subspace that the interpolation path, $F(t)$, is traversing. In other words, preprojection step make sure the interpolation path between two frames $F_a$ and $F_z$ is not going to the data space that is not related to $F_a$ and $F_z$. Simply, prepojection algorithm is defining the joint subspace of $F_a$ and $F_z$. 

The procedure starts with forming an orthonormal basis by applying Gram-Schmidt to $F_z$ with regard to $F_a$. We denote this orthonormal basis by $F_\star$. Then build preprojection basis $B$ by combining $F_a$ and $F_\star$ as follows:

$$B = (F_a, F_{\star})$$

The dimension of the resulting orthonormal basis, $B$, is $p\times 2d$.

Then, we can express the original frames in terms of this basis:

$$F_a = B^TW_a, F_z = B^TW_z$$

The interpolation problem is then reduced to the construction of paths of frames $W(t)$ that interpolate the preprojected frames $W_a$ and $W_z$. Because $B$ is orthonormalized basis of $F_z$ with regard to $F_a$, $W_a$ is $2d\times d$ matrix of 1, 0s. This is an important character for our interpolation algorithm of choice, Givens interpolation. 

**Givens interpolation path algorithm**

A rotation matrix is a transformation matrix used to perform a rotation in Euclidean space in a plane. A rotation matrix that transforms 2D plane by an angle $\theta$ looks like this:

$$ \begin{bmatrix}\cos \theta &-\sin \theta \\\sin \theta &\cos \theta \end{bmatrix} $$

If the rotation is in the plane of selected 2 variables, it is called Givens rotation. Let's denote those 2 variables $i$ and $j$. The Givens rotation is useful for introducing zeros on a grand scale and used for computing the QR decomposition of matrix in linear algebra problems. One advantage over other transformation methods which is particularly useful in our case is the ability to zero elements more selectively.

The interpolation methods in the **woylier** package is based on the fact that in any vector of a matrix, one can zero out the $i$-th coordinate with a Givens rotation [@matrix_computation] in the $(i, j)$-plane for any $j\neq i$. This rotation affects only coordinate $i$ and $j$ and leave all other coordinates unchanged. 

Sequences of Givens rotations can map any orthonormal d-frame F in p-space to standard d-frame $E_d=((1, 0, 0, ...)^T, (0, 1, 0, ...)^T, ...)$. 

The interpolation path construction algorithm from starting frame $F_a$ to target frame $F_z$ is illustrated below. The example is 2D path construction process of original 6D data frame. 

1. Construct preprojection basis $B$ by orthonormalizing $F_z$ with regards tp $F_a$ with Gram-Schmidt.

In our example, $F_a$ and $F_z$ are $p\times d$ or $6\times2$ matrices that are orthonormal. The preprojection basis $B$ is $p\times 2d$ matrix that is $6\times 4$.

2. Get the preprojected frames using the preprojection basis $B$.
$$W_a = B^TF_a = E_d$$ and $$W_z = B^TF_z$$

In our example, $W_a$ looks like:


$$ \begin{bmatrix}1 & 0 \\0  &1 \\ 0&0 \\0&0\end{bmatrix} $$

$W_z$ is orthonormal $2d\times d$ matrix that looks like:

$$ \begin{bmatrix} a_{11} & a_{12} \\a_{21}  &a_{22} \\ a_{31}&a_{32} \\a_{41}&a_{42}\end{bmatrix} $$


3. Then, we can construct a sequence of Givens rotations that maps $W_z$ to $W_a$ with such angles that makes one element zero at a time:

$$ W_a = R_m(\theta_m) ... R_2(\theta_2)R_1(\theta_1)W_z$$ 

At each rotation, the angle $\theta_i$ that zero out the second coordinate of a plane is calculated.

When $d = 2$, there are 5 rotations involved with 5 different angles that makes each elements 0. For example, the first rotation angle $\theta_1$ is an angle in radian between $(1, 0)$ and $(a_{11}, a_{21})$. This rotation matrix would make element $a_{21}$ zero:

$$R_1(\theta_1) = G(1, 2, \theta_1) = \begin{bmatrix} cos\theta_1 & -sin\theta_1 & 0 & 0 \\sin\theta_1  &cos\theta_1 & 0 &0 \\ 0&0&1&0 \\0&0&0&1\end{bmatrix}$$

6th rotation is not necessary due to orthonormality of columns. If we make one element of a column 1 that means all other elements must be 0. 

4. The inverse mapping is obtained by reversing the sequence of rotations with the negative of the angles, we starts from the starting basis and end at the target basis. 

$$R(\theta) = R_1(-\theta_1) ... R_m(-\theta_m), \    W_z = R(\theta)W_a$$

Performing these rotations would go from the starting frame to the target frame in one step. But we want to do it sequentially in a number of steps so interpolation between frames looks dynamic. 

5. Next step should include the time parameter, $t$, so that it shows the interpolation process rendered in the movie-like sequence. We break $\theta_i$ into the number of steps, $n-step$, that we want to go from starting frame to the target frame, which means it moves by equal angle in each step. 

6. Finally, we reconstruct our original frames using $B$. This reconstruction is done at each step of interpolation so that we have interpolated path as result. We use $F_t$ to project the orignal data into lower dimensions.

$$F_t = B  W_t$$

**Projection pursuit index functions**

The properties of several projection pursuit index functions were investigated in @pp. The smoothness, squintability, flexibility, rotation invariance, and speed of projection pursuit index functions were examined. The one property that is interesting to us is rotation invariance. The rotational invariance is examined by computing projection pursuit index for different rotations within 2D plane. It is established that the `dcor2d`, `splines2d` and `TIC` index are not strictly rotationally invariant. The `splines2d` index measures nonlinear association between variable by fitting spline model. It compares the variance of residuals and the functional dependence is stronger when the index value is larger.

# Implementation

We implemented each steps in Givens interpolation path algorithm in separate functions and combined them in `givens_full_path()` function. Here is the input and output of each functions and it's descriptions.

```{r}
tbl <- tibble(name = c("`givens_full_path(Fa, Fz, nsteps)`",
                    "`preprojection(Fa, Fz)`", 
                    "`construct_preframe(Fa, B)`", 
                    "`row_rot(a, i, k, theta)`",
                    "`calculate_angles(Wa, Wz)`",
                    "`construct_moving_frame(Wt, B)`"),
              description = c("Construct full interpolated frames.",
                              "Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa.", 
                              "Construct preprojected frames.", 
                              "Performs Givens rotation .",
                              "Calculate angles of required rotations to map Wz to Wa.", 
                              "Reconstruct interpolated frames using pre-projection. "), 
              input = c("Starting and target frame (Fa, Fz) and number of steps", 
                        "Starting and target frame (Fa, Fz) ", 
                        "A frame and the pre-projection p x 2D matrix", "A frame and the pre-projection p x 2D matrix", 
                        "Preprojected frames (Wa, Wz)",
                        "Pre-projection matrix B, Each frame of givens path"),
              output = c("An array with nsteps matrix. Each matrix is interpolated frame in between starting and target frames.", 
                         "B pre-projection p x 2D matrix",
                         "Pre-projected frame in pre-projection space", 
                         "theta angle rotated matrix a", 
                         "Names list of angles",
                         "A frame of on a step of interpolation"))
```

```{r fns-html, eval=knitr::is_html_output()}
kbl(tbl, escape = FALSE) %>%
  column_spec(1, width="30em") %>%
  column_spec(2, width="25em") %>%
  column_spec(3, width="20em") %>%
  column_spec(4, width="30em") %>%
  row_spec(2, extra_css = "vertical-align: left!important;") %>%
  row_spec(3, extra_css = "vertical-align: left!important;") %>%
  row_spec(4, extra_css = "vertical-align: left!important;") %>%
  row_spec(5, extra_css = "vertical-align: left!important;") %>%
  row_spec(6, extra_css = "vertical-align: left!important;")
```

```{r fns-pdf, eval=knitr::is_latex_output(), results='asis'}
#library(xtable)
#print(xtable(tbl, caption="Primary functions in the woylier package.", label="fns-pdf", caption.placement="top"))
tbl <- tibble(name = c("givens_full_path(Fa, Fz, nsteps)",
                    "preprojection(Fa, Fz)", 
                    "construct_preframe(Fa, B)", 
                    "row_rot(a, i, k, theta)",
                    "calculate_angles(Wa, Wz)",
                    "construct_moving_frame(Wt, B)"),
              description = c("Construct full interpolated frames.",
                              "Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa.", 
                              "Construct preprojected frames.", 
                              "Performs Givens rotation .",
                              "Calculate angles of required rotations to map Wz to Wa.", 
                              "Reconstruct interpolated frames using pre-projection. "), 
              input = c("Starting and target frame (Fa, Fz) and number of steps", 
                        "Starting and target frame (Fa, Fz) ", 
                        "A frame and the pre-projection p x 2D matrix", "A frame and the pre-projection p x 2D matrix", 
                        "Preprojected frames (Wa, Wz)",
                        "Pre-projection matrix B, Each frame of givens path"),
              output = c("An array with nsteps matrix. Each matrix is interpolated frame in between starting and target frames.", 
                         "B pre-projection p x 2D matrix",
                         "Pre-projected frame in pre-projection space", 
                         "theta angle rotated matrix a", 
                         "Names list of angles",
                         "A frame of on a step of interpolation"))
kbl(tbl) %>%
  row_spec(0, bold=TRUE) %>%
  column_spec(1, width="5cm", monospace=T) %>%
  column_spec(2, width="3cm") %>%
  column_spec(3, width="2cm") %>%
  column_spec(4, width="2cm") 
```

<!--
- `givens_full_path(Fa, Fz, nsteps)`: Construct full interpolated frames.   
    - `input`: Starting and target frame (Fa, Fz) and number of steps 
    - `output`: An array with nsteps matrix. Each matrix is interpolated frame in between starting and target frames. 
- `preprojection(Fa, Fz)`: Build a d-dimensional pre-projection space by orthonormalizing Fz with regard to Fa.
    - `input`:  Starting and target frame (Fa, Fz) 
    - `output`: B pre-projection px2d matrix 
- `construct_preframe(Fa, B)`: Construct preprojected frames.
    - `input`: A frame and the pre-projection px2d matrix
    - `output`: Preprojected frame in preprojection space
- `row_rot(a, i, k, theta)`: Performs Givens rotation [@matrix_computation].
    - `input`: a-matrix, i-row, k-row that we want to zero the element, theta-angle between i, k rows
    - `output`: theta angle rotated matrix a 
- `calculate_angles(Wa, Wz)`: Calculate angles of required rotations to map Wz to Wa.
    - `input`:  Preprojected frames (Wa, Wz)
    - `output`: Names list of angles
- `givens_rotation(Wa, angles, stepfraction)`: It implements series of Givens rotations that maps Wa to Wz
    - `input`: Wa starting preprojected frame, list of angles of required rotations to map Wz to Wa, stepfraction.
    - `output`: Givens path 
- `construct_moving_frame(Wt, B)`: Reconstruct interpolated frames using pre-projection. 
    - `input`: Pre-projection matrix B, Each frame of givens path
    - `output`: A frame of on a step of interpolation
-->

The interface of tour is that it renders one projection of data at a time. It displays one projection and asks for the next projection. Therefore, path of projections shown below is sequence of projections to be renders at tour display.

The `givens_full_path()` function returns the intermediate interpolation step projections in given number of steps. The code chunk below demonstrates the interpolation between 2 random basis in 5 steps.

```{r echo=TRUE}
set.seed(2022)
p <- 6
base1 <- tourr::basis_random(p, d=2)
base2 <- tourr::basis_random(p, d=2)

base1
base2
```

```{r echo=TRUE}
givens_full_path(base1, base2, nsteps = 5)
```


# Comparison of geodesic interpolation and Givens interpolation

In this section, we illustrate the use of *givens_full_path()* function by plotting the interpolated path between 2 frames. This also a way of checking if interpolated path is moving in equal size at each step.

For plotting the interpolated path of projections, we used \CRANpkg{geozoo} package [@geozoo]. 1D projection is plotted on unit sphere, while 2D projection is visualized on torus. The points on the surface of sphere and torus shape are randomly generated by functions from the \CRANpkg{geozoo} package.

**Interpolated paths of 1D projection**

1D projection of data in high dimension linear combination of data that is normalized. Therefore, we can plot the point on the surface of a hypersphere. Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:1d-path-dynamic)', '\\@ref(fig:1d-path-static)'))` shows the Givens interpolation steps between 2 points, 1D projection of 6D data that is. 

```{r echo = FALSE, eval=FALSE}
set.seed(315)
p <- 3
n <- 2000
base1 <- tourr::basis_random(p, d=1)
base2 <- tourr::basis_random(p, d=1)

frames <- givens_full_path(base1, base2, nsteps = 10)

base <- save_history(flea[,1:3], grand_tour(1), max_bases = 2)
base[,,1] <- base1[,1]
base[,,2] <- base2[,1]
planes <- interpolate(base, angle=proj_dist(base1, base2)/10)[,,1:10] #last plane duplicated

sp <- generate_space_view(n=n, p=p)

sp_path <- add_path(sp, frames)
sp_path <- add_path(sp_path, planes)
# Correct labels
sp_path$type[(n+1):(n+10)] <- "f_path"
sp_path$type[(n+11):(n+20)] <- "p_path"

point1 <- as.data.frame(t(base1))
point1$type <- "point1"

point2 <- as.data.frame(t(base2))
point2$type <- "point2"

sp_path <- rbind(sp_path, point1, point2)
#sp_path$type <- factor(sp_path$type, 
#                       levels = c("point1", "path", "proj_space", 
#                                  "point2"))  

# Colours from
# paletteer::scale_colour_paletteer_d("rcartocolor::TealRose")
clrs <- c("#F1EAC8FF", "#B1C7B3FF", "#72AAA1FF", "#009392FF", "#E5B9ADFF", "#D98994FF", "#D0587EFF",
          "lightgrey")
sp_path$typecol <- case_when(sp_path$type=="proj_space" ~ clrs[1],
                             sp_path$type=="point1" ~ clrs[8],
                             sp_path$type=="f_path" ~ clrs[3],
                             sp_path$type=="point2" ~ clrs[4],
                             sp_path$type=="p_path" ~ clrs[6])

edges <- matrix(c(n+20+1, seq(n+1, n+10, 1), seq(n+11, n+19, 1), nrow(sp_path), seq(n+1, n+10, 1), n+20+2, seq(n+12, n+20, 1), n+20), ncol=2, byrow=FALSE)
edges.col <- c(rep(clrs[3], 10), rep(clrs[6], 10), clrs[1]) #factor(rep("path", 10), levels=c("point1", "path", "proj_space", 
                                  "point2"))
  
cex <- c(rep(1, n), rep(3, nrow(sp_path)-n))
  
animate_xy(as.matrix(sp_path[,1:p]), axes="off",
           col=sp_path$typecol,
           edges=edges,
           edges.col=edges.col,
           edges.width=3,
           cex=cex)

tourr::render_gif(as.matrix(sp_path[,1:p]), 
                  tour_path = grand_tour(),
                  display = display_xy(axes="off",
                      col=sp_path$typecol,
                      edges=edges,
                      edges.col=edges.col,
                      edges.width=3,
                      cex=cex),
                  frames = 100,
                  "sphere.gif")
```

```{r 1d-path-dynamic, out.width="45%", fig.align="center", echo = FALSE, fig.height = 3, fig.show='hold', fig.cap="Interpolation steps of 1D and 2D projections of 3D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "Two highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."}
knitr::include_graphics(c("sphere.gif", "torus.gif"))
```

```{r 1d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.show='hold', fig.cap="Interpolation steps of 1D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."}
knitr::include_graphics(c("sphere_static.png", "torus_static.png"))
```

**Interpolated paths of 2D projection**

In case of 2D projections, we can plot the interpolated path between 2 frames on the surface of torus. Torus can be seen as crossing of 2 circles that are orthonormal. Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:2d-path-dynamic)', '\\@ref(fig:2d-path-static)'))` shows the Givens interpolation steps in 2D projection of 6D data.

For a 2D projection the same target plane is found when rotating the basis within the plane, or when reflecting across one of the two directions (the reflected basis can then also be rotating). This means the space of target bases is constrained to two circles in the high-dimensional space, and these are disconnected because the reflection corresponds to a jump along the torus surface. In the high-dimensional space we can imagine the reflection as flipping over the target plane, resulting in a reflection of the normal vector on the plan.
While the Givens interpolation will reach the exact basis, a geodesic interpolation towards the same target plane can land anywhere along those two circles, depending on the starting basis in the interpolation.

```{r echo = FALSE, eval=FALSE}
set.seed(319)
p <- 3
n <- 5000
d <- 2
base1 <- orthonormalise(tourr::basis_random(p, d=2))
base2 <- orthonormalise(tourr::basis_random(p, d=2))
# generating the torus spanning the space
proj_2d <- map(1:n, ~basis_random(n=p,  d=2)) %>%
  purrr::flatten_dbl() %>%
  matrix(ncol = p*2, byrow = TRUE) %>%
  as.tibble() %>% 
  mutate(type="torus")
# Givens path, fixing number of steps to 100
frames_2d <- givens_full_path(base1, base2, 100)
path_2d <- rbind(as.data.frame(t(as.vector(base1))),
                 as.data.frame(t(apply(frames_2d, 3, c)))) %>%
  mutate(type = "givens")
# Geodesic path, also taking 100 steps
pt_geo <- save_history(flea[, 1:p], planned_tour(list(base1, base2)))
int_geo <- interpolate(pt_geo, angle = proj_dist(base1, base2)/100)[,,1:101]
# the last plane is duplicate of the target
path_2d_geo <- as.data.frame(t(apply(int_geo, 3, c))) %>%
  mutate(type = "geodesic")
# generating the equivalent bases (rotations in the target plane)
base2_rot_1 <- matrix(ncol = 6, nrow = 41)
base2_rot_2 <- matrix(ncol = 6, nrow = 41)
i <- 1
base2_2 <- base2
base2_2[,2] <- -base2_2[,2]
flip_connect <- matrix(ncol = 7, nrow = 0) # don't know how many entries we will need, so will use rbind
for (a in seq(0,2*pi, pi/20)){
    rotM <- matrix(c(cos(a), sin(a), -sin(a), cos(a)), ncol = 2)
    dprj_1 <- base2 %*% rotM
    base2_rot_1[i,] <- as.vector(dprj_1)
    rot2 <- matrix(c(cos(a+pi/4), sin(a+pi/4), -sin(a+pi/4), cos(a+pi/4)), ncol = 2)
    dprj_2 <- base2_2 %*% rot2
    base2_rot_2[i,] <- as.vector(dprj_2)
    flip_connect <- rbind(flip_connect, (t(c(as.vector(dprj_1),i))),
                 cbind(t(apply(
                   givens_full_path(dprj_1, dprj_2, 30),
                   3, c)),
                   i))
    cat(proj_dist(base2, dprj_1), proj_dist(base2_2, dprj_2), "\n")
    i <- i+1
}

connect_flipped <- as.data.frame(flip_connect) %>% 
  filter(!is.nan(V1)) %>%
  mutate(type="connect")
rot_base2 <- as.data.frame(rbind(base2_rot_1, base2_rot_2)) %>% 
  mutate(type="target")
# starting base as tibble
start_2d <- as.tibble(t(as.vector(base1))) %>%
  mutate(type = "start")
# putting everything together
proj_path <- bind_rows(proj_2d, rot_base2, #connect_flipped,
                       path_2d, path_2d_geo, start_2d)


# Colours from
# paletteer::scale_colour_paletteer_d("rcartocolor::TealRose")
clrs <- c("#F1EAC8FF", "#B1C7B3FF", "#72AAA1FF", "#009392FF", "#E5B9ADFF", "#D98994FF", "#D0587EFF",
          "lightgrey")
proj_path$typecol <- case_when(proj_path$type=="torus" ~ clrs[1],
                             proj_path$type=="start" ~ clrs[8],
                             proj_path$type=="givens" ~ clrs[3],
                             proj_path$type=="target" ~ clrs[8],
                             proj_path$type=="geodesic" ~ clrs[6],
                             proj_path$type=="connect" ~ clrs[8])
edges <- matrix(c(which(proj_path$type=="target")[1:40], # starting nodes for target
                  which(proj_path$type=="target")[42:81], # starting nodes for flipped target
                  head(which(proj_path$type=="givens"),-1), # starting nodes for givens
                  head(which(proj_path$type=="geodesic"),-1), # starting nodes for geodesic
                  which(proj_path$type=="target")[2:41], # ending nodes for target
                   which(proj_path$type=="target")[43:82], # starting nodes for flipped target
                  tail(which(proj_path$type=="givens"),-1), # ending nodes for givens
                  tail(which(proj_path$type=="geodesic"),-1)), # ending nodes for geodesic
                ncol=2, byrow=FALSE)
edges.col <- c(rep(clrs[1], sum(proj_path$type=="target")-1),
               rep(clrs[3], sum(proj_path$type=="givens")-1),
               rep(clrs[6], sum(proj_path$type=="geodesic")-1)) 

cex <- c(rep(0.5, n+41), rep(1, nrow(proj_path)-(n+41)))
cex[which(proj_path$type == "start")] <- 2
cex[which(proj_path$type == "target")] <- 0.1

animate_xy(as.matrix(proj_path[,1:(2*p)]), 
           axes="off",
           col=proj_path$typecol,
           edges=edges,
           edges.col=edges.col,
           edges.width=3,
           cex=cex)

tourr::render_gif(as.matrix(proj_path[,1:(2*p)]), 
                  tour_path = grand_tour(),
                  display = display_xy(axes="off", 
                    col=proj_path$typecol,
                    edges=edges,
                    edges.col=edges.col,
                    edges.width=3,
                    cex=cex),
                  frames = 100,
                  "torus.gif")
```

<!--
```{r 2d-path-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."}

knitr::include_graphics("torus.gif")
```

```{r 2d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."}

knitr::include_graphics("torus_static.png")
```
-->

```{r echo = FALSE, eval=FALSE}
# trying with more information in one animation
set.seed(2022)
p <- 6
n <- 5000
d <- 2
base1 <- tourr::basis_random(p, d=2) # this is start 1
base2 <- tourr::basis_random(p, d=2)
start2 <- tourr::basis_random(p, d=2)
start3 <- tourr::basis_random(p, d=2)
frames_2d <- givens_full_path(base1, base2, 100)
frames_2d_2 <- givens_full_path(start2, base2, 100)
frames_2d_3 <- givens_full_path(start3, base2, 100)
proj_2d <- map(1:n, ~basis_random(n = p,  d=d)) %>%
  purrr::flatten_dbl() %>% 
  matrix(ncol = p*2, byrow = TRUE) %>%
  as_tibble()
path_2d <- rbind(as.data.frame(t(as.vector(base1))),
                 as.data.frame(t(apply(frames_2d, 3, c))),
                 as.data.frame(t(as.vector(start2))),
                 as.data.frame(t(apply(frames_2d_2, 3, c))),
                 as.data.frame(t(as.vector(start3))),
                 as.data.frame(t(apply(frames_2d_3, 3, c)))) %>%
#<- t(apply(frames_2d, 3, c)) %>% 
  #as.data.frame() %>% 
  mutate(type="givens")
proj_2d <- proj_2d %>% 
  mutate(type="torus")
pt_geo <- save_history(flea[, 1:p], planned_tour(list(base1, base2)))
int_geo <- interpolate(pt_geo)
pt_geo_2 <- save_history(flea[, 1:p], planned_tour(list(start2, base2)))
int_geo_2 <- interpolate(pt_geo_2)
pt_geo_3 <- save_history(flea[, 1:p], planned_tour(list(start3, base2)))
int_geo_3 <- interpolate(pt_geo_3)
path_geo <- rbind(as.data.frame(t(apply(int_geo, 3, c))),
                  as.data.frame(t(apply(int_geo_2, 3, c))),
                  as.data.frame(t(apply(int_geo_3, 3, c)))) %>%
  #t(apply(int_geo, 3, c)) %>% 
  #as.data.frame() %>% 
  mutate(type="geodesic")

base2_rot <- matrix(ncol = 12, nrow = 2*201)
i <- 1
for (a in seq(0,2*pi, pi/100)){
    rotM <- matrix(c(cos(a), sin(a), -sin(a), cos(a)), ncol = 2)
    dprj <- base2 %*% rotM
    base2_rot[i,] <- as.vector(dprj)
    i <- i+1
    dprj <- base2[,c(2,1)] %*% rotM
    base2_rot[i,] <- as.vector(dprj)
    i <- i+1
}
rot_base2 <- as.data.frame(base2_rot) %>% 
  mutate(type="target")
proj_path <- bind_rows(proj_2d, path_2d, path_geo, rot_base2)
proj_path$type <- factor(proj_path$type, levels=c("torus", "target",
                                               "givens", "geodesic"))
proj_path <- arrange(proj_path, type)
animate_xy(proj_path[,1:12], col=proj_path$type, palette="Teal-Rose", 
           cex=c(rep(0.5, n), rep(1, nrow(proj_path)-n)),
                 axes="off")

```


In this section, we used simulated data for comparing geodesic and Givens interpolation paths. The data has 6 variables and 500 observations. The variable 5 and 6 has sine structure and the remaining variables are randomly generated from normal distribution. The sine is non-linear structure and can be detected using splines2d index. 

Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:compare-interpolations)', '\\@ref(fig:compare-interpolations-static)'))` shows the Geodesic and Givens interpolation to target frame where the two variables forms sine curve. 

```{r echo = FALSE, eval=FALSE}
# Generate a sample interpolation
set.seed(5543)
base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
base2 <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1), ncol=2, byrow=T)
sine_path <- givens_full_path(base1, base2, nsteps=100)
sine_all <- NULL
sine_proj <- NULL
for (i in 1:dim(sine_path)[3]) {
  d <- as.matrix(sine_curve) %*% as.matrix(sine_path[,,i])
  d <- data.frame(d)
  d$idx <- round(tourr::splines2d()(d), 2)
  d$frame <- i
  sine_all <- bind_rows(sine_all, d)
  prj <- as.data.frame(sine_path[,,i])
  prj$frame <- i
  prj$names <- colnames(sine_curve)
  sine_proj <- bind_rows(sine_proj, prj)
}
sine_label <- sine_all %>%
  mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
sine_proj <- sine_proj %>%
  mutate(cx = 0, cy = 0)
# With gganimate

sine_anim <- ggplot() +
  geom_segment(data=sine_proj, aes(x=V1, y=V2,
                                   xend=cx, yend=cy,
                                   group=frame),
               colour="grey60") +
  geom_text(data=sine_proj, aes(x=V1, y=V2,
                                label=names,
                                group=frame),
               colour="grey60") +
  geom_point(data=sine_label, aes(x=X1, y=X2)) +
  geom_text(data=sine_label, aes(x=labelX, y=labelY,
                label=label_idx), size=10) +
  xlab("") + ylab("") +
  transition_time(frame) +
  theme_void() +
  theme(aspect.ratio=1,
        plot.background = element_rect(fill=NULL, colour = "black"))

animate(sine_anim, fps=8, renderer = gifski_renderer(loop = FALSE), width=400, height=400)
anim_save("sine_anim_givens.gif")
```


```{r echo = FALSE, eval=FALSE}
library(tourr)
set.seed(5541)
base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
base2 <- matrix(c(0,0,0,0,0,0,0,0,1, 0, 0, 1), ncol = 2, byrow = TRUE)
basis_set <- array(dim = c(6,2,2))
basis_set[,,1] <- base1
basis_set[,,2] <- base2
attr(basis_set, "class") <- c("history_array", class(basis_set))
path_geo <- tourr::interpolate(basis_set, angle = 0.0151)
data("sine_curve")

sine_all <- NULL
sine_proj <- NULL
for (i in 1:dim(path_geo)[3]) {
  d <- as.matrix(sine_curve) %*% matrix(c(path_geo[,,i][[1]]), ncol = 2)
  d <- data.frame(d)
  d$idx <- round(tourr::splines2d()(d), 2)
  d$frame <- i
  sine_all <- bind_rows(sine_all, d)
  prj <- as.data.frame(matrix(c(path_geo[,,i][[1]]), ncol = 2))
  prj$frame <- i
  prj$names <- colnames(sine_curve)
  sine_proj <- bind_rows(sine_proj, prj)
}
sine_label <- sine_all %>%
  mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
sine_proj <- sine_proj %>%
  mutate(cx = 0, cy = 0)

# With gganimate
sine_anim <- ggplot() +
  geom_segment(data=sine_proj, aes(x=V1, y=V2,
                                   xend=cx, yend=cy,
                                   group=frame),
               colour="grey60") +
  geom_text(data=sine_proj, aes(x=V1, y=V2,
                                label=names,
                                group=frame),
               colour="grey60") +
  geom_point(data=sine_label, aes(x=X1, y=X2)) +
  geom_text(data=sine_label, aes(x=labelX, y=labelY,
                label=label_idx), size=10) +
  xlab("") + ylab("") +
  transition_time(frame) +
  theme_void() +
  theme(aspect.ratio=1,
        plot.background = element_rect(fill=NULL, colour = "black"))

animate(sine_anim, fps=8, renderer = gifski_renderer(loop = FALSE), width=400, height=400)
anim_save("sine_anim_geodesic.gif")
```

<!--
```{r compare-interpolations, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."}
knitr::include_graphics(
  c("sine_anim_givens.gif",
    "sine_anim_geodesic.gif"))
```

```{r compare-interpolations-static, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."}
knitr::include_graphics(
  c("given_sine.png",
    "geodesic_sine.png"))
```
-->

# Data application

This section describes the application of Givens interpolation path with guided tour to explore non-linear association in multivariate data. 

We have cross-rates for currencies relative to the US dollar. A cross-rate is an exchange rate between two currencies computed by reference to a third currency, usually the US dollar. 

The data was extracted from [openexchangerates](https://openexchangerates.org) and contains cross-rate for ARS, AUD, EUR, JPY, KRW, MYR between 2019-11-1 to 2020-03-31. Figure `r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:currency)', '\\@ref(fig:currency)'))` shows how the currencies changed relative to USD over the time period. We see some collective behavior in March of 2020 with EUR and JPY increasing in a similar manner, and smaller currencies decreasing in value. This could be understood as a consequence of flight-to-quality at this uncertain times.  

```{r currency, out.width="100%", fig.width = 9, fig.height = 4.5, layout = "l-body", fig.cap="All the currencies are standardised and the sign is flipped. The high value means the currency strengthened against the USD, and low means that it weakened."}
rates <- read_csv("rates_Nov19_Mar20.csv", show_col_types = FALSE) %>% 
  select(date, ARS, AUD, EUR, JPY, KRW, MYR) 
rates_sub <- rates %>%
  mutate_if(is.numeric, function(x) -1*(x-mean(x))/sd(x))
rates_sub_long <- rates_sub %>% 
  pivot_longer(cols=ARS:MYR, 
               names_to="currency",
               values_to="crossrate") 
ggplot(rates_sub_long, aes(x=date, y=crossrate, colour=currency)) +
  geom_line() +
  scale_colour_brewer("", palette = "Dark2") +
  theme_bw() +
  theme(aspect.ratio = 0.3,
        legend.position = "bottom")
# saving months for coloring in later
rate_march <- lubridate::month(rates$date)==3
```

We are interested in capturing this relations over time, and from the time series visualization we expect that we can capture the main dynamics in a two-dimensional projection from the six-dimensional space of currencies. Thus we start from $p=6$ (the different currencies) and $n=152$ the number of days in our sample. We expect that a projection onto $d=2$ dimensions should capture the relation between the two groups of currencies mentioned above, and this should be identified within the noise of the random fluctuations.

**PCA result**

Since the collective behavior observed in March 2020 clearly stands out in the time series display, we may expect that we can capture the dependence between the two groups using principal components analysis. Figure \@re(pca-result-static)
<!--`r knitr::asis_output(ifelse(knitr::is_html_output(), '\\@ref(fig:pca-result)', '\\@ref(fig:pca-result)'))`--> shows a scatter plot matrix of the PCs of our dataset. Indeed we find strong non-linear association between the first two PCs. Investigation of the rotation shows that the first principal component is primarily a balanced combination between ARS, AUD, KRW and MYR (and a smaller contribution of EUR), and the second contribution is dominated by EUR and JPY contrasted with smaller contributions from ARS and MYR. Our next step is thus to use projection pursuit to identify the best projection matrix that captures the non-linear functional dependence.

```{r pca-result-static, echo=FALSE, out.width="80%", fig.width=8, fig.height=8, fig.align = "center", fig.show='hold', fig.cap="There is a strong non-linear dependence between PC1 and PC2. Observations in March 2020 are highlighted in dark blue, all other months are shown in grey."}
# Use PCA to remove linear dependence
rates_pca <- prcomp(rates[,-1], scale. = TRUE)
pca <- ggscatmat(cbind(tibble::as_tibble(rates_pca$x), rate_march),
                 color = "rate_march") +
  scale_color_manual(values = c("grey", "darkblue")) +
  theme_bw() +
  theme(aspect.ratio = 1,
        legend.position = "none") +
  xlab("") + ylab("")
pca
```

<!--
```{r pca-result, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="There is a strong non-linear dependence between PC1 and PC2."}
# Use PCA to remove linear dependence
rates_pca <- prcomp(rates[,-1], scale. = TRUE)
pca <- ggscatmat(rates_pca$x)
pca
```
-->

**New splines2d index**

We now use the splines index to identify a projection with functional dependence between the first and second direction of the projection. Note here that because of strong linear correlations between the currencies, we start from the first four principal components, explaining over 99% of the variance in the data. To avoid starting from the view already identified in the first two principal components we start from a projections onto the third and forth principal components. The PCA display in `tourr` to show the projection in terms of the original variables while only touring within the smaller space spanned by the first four principal components.

```{r}
rates_pca_sd <-  apply(rates_pca$x, 2, function(x) (x-mean(x))/sd(x))
```

```{r echo = FALSE, eval=FALSE}
# modified the splines2d
# same as defined above, but keeping this block self-contained
new_splines2d <- function ()
{
  function(mat) {
    mat <- as.data.frame(mat)
    colnames(mat) <- c("x", "y")
    kx <- ifelse(length(unique(mat$x[!is.na(mat$x)])) < 20,
                 3, 10)
    mgam1 <- mgcv::gam(y ~ s(x, bs = "cr", k = kx), data = mat)
    measure <- 1 - var(residuals(mgam1), na.rm = T)/var(mat$y, na.rm = T)
    return(measure)
  }
}
library(tourr)
col_rates <- rep("grey", nrow(rates))
col_rates[rate_march] <- "darkblue"
basis_start <- matrix(rep(0, 8), ncol = 2)
basis_start[3,1] <- 1
basis_start[4,2] <- 1
set.seed(2023)
record_search_geodesic <- animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
            tour_path = guided_tour(new_splines2d(), current = basis_start),
            col = col_rates)
set.seed(2023)
record_search_givens <- animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
           tour_path = guided_tour_givens(new_splines2d(),
                                          current = basis_start,
                                          optim = "search_better",
                                          max.tries = 100,
                                          alpha = 1),
           col = col_rates)
set.seed(2023)
record_search_better <-animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
           tour_path = guided_tour(new_splines2d(),
                                          current = basis_start,
                                          search_f = search_better,
                                          max.tries = 100,
                                          alpha = 1),
           col = col_rates)
save(record_search_better, record_search_geodesic, record_search_givens,
     file = "rates_tour_records.RData")
```

```{r echo = FALSE, eval=FALSE}
# generating gifs for the three guided tours
load("rates_tour_records.RData")
library(ferrn)
path_geodesic <- get_interp(record_search_geodesic)$basis
path_better <- get_interp(record_search_better)$basis
path_givens <- get_interp(record_search_givens)$basis

col_rates <- rep("grey", nrow(rates))
col_rates[rate_march] <- "darkblue"
# it seems this is using smaller interpolation steps so we set frames to
# some high number to make sure we capture the full path
tourr::render_gif(rates_pca_sd[,1:4],
                  display = display_pca(col = col_rates,
                                        pc_coefs = rates_pca$rotation[,1:4]),
                  tour_path = planned_tour(path_geodesic),
                  "rates_tour_geodesic.gif", frames = 500,
                  loop = FALSE, width=200, height=200)

tourr::render_gif(rates_pca_sd[,1:4],
                  display = display_pca(col = col_rates,
                                        pc_coefs = rates_pca$rotation[,1:4]),
                  tour_path = planned_tour_givens(path_givens),
                  "rates_tour_givens.gif", frames = 500,
                  loop = FALSE, width=200, height=200)

tourr::render_gif(rates_pca_sd[,1:4],
                  display = display_pca(col = col_rates,
                                        pc_coefs = rates_pca$rotation[,1:4]),
                  tour_path = planned_tour(path_better),
                  "rates_tour_better.gif", frames = 1000,
                  loop = FALSE, width=200, height=200)

```

```{r rates-tour-animated, echo=FALSE, out.width="33%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="Optimisation in the guided tour using geodesic optimisation (left), simulated annealing with geodesic interpolation (middle) and simulated annealing with givens interpolation (right). (Refresh page to re-start the animation.)"}
knitr::include_graphics(
  c("rates_tour_geodesic.gif",
    "rates_tour_better.gif",
    "rates_tour_givens.gif"))
```


```{r rates-tour-static, out.width="30%", fig.align="center", echo = FALSE, fig.show='hold', include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.cap="Final view after optimisation in the guided tour using geodesic optimisation (left), simulated annealing with geodesic interpolation (middle) and simulated annealing with givens interpolation (right)."}
knitr::include_graphics(c("rates_tour_geodesic_final.png",
    "rates_tour_better_final.png",
    "rates_tour_givens_final.png"))
```

```{r echo=FALSE, eval=TRUE}
load("rates_tour_records.RData")
library(ferrn)
p1 <- get_interp(record_search_geodesic) %>%
  ggplot(aes(id, index_val)) +
  geom_line() +
  geom_point(data = dplyr::bind_rows(get_start(record_search_geodesic),
                                     get_interp_last(record_search_geodesic))) +
  ylim(0,1) +
  xlab(NULL) +
  ylab(NULL) +
  theme_bw()

             
p2 <- get_interp(record_search_better) %>%
  ggplot(aes(id, index_val)) +
  geom_line() +
  geom_point(data = dplyr::bind_rows(get_start(record_search_better),
                                     get_interp_last(record_search_better))) +
  ylim(0,1)+
  xlab(NULL) +
  ylab("Index value") +
  theme_bw() 
          

p3 <- get_interp(record_search_givens) %>%
  ggplot(aes(id, index_val)) +
  geom_line() +
  geom_point(data = dplyr::bind_rows(get_start(record_search_givens),
                                     get_interp_last(record_search_givens))) +
  ylim(0,1)+
  xlab("Interpolation step") +
  ylab(NULL) +
  theme_bw() 

gridExtra::grid.arrange(p1, p2, p3, ncol = 1)
```

What do we learn from looking at the traces?

- geodesic search does not have problem from rotation dependent index because it is searching along geodesic path, so everything is consistent, but it can get stuck and cannot jump to better solutions
- instead we might want to use random search (simulated annealing), but here we have huge problems from the rotation dependence of the index - even though this search should only accept target planes with higher index values we get big drops just because of the change in index value after rotation, the search path is very long and cannot find a good optimum
- using givens interpolation with the random search can fix these issues, we can step across valleys with lower index values but each target plane is increasing the index value, we do not need to restart the search - even with longer interpolations from the within-plane rotation this search is much more efficient (shorter path), the final index value in our run is above what the random search with geodesic interpolation has found, the final view is certainly more interesting


```{r guided-geo-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of splines index using geodesic interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()}
#knitr::include_graphics("guided_geo.gif")
```


```{r guided-geo-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of splines index using geodesic interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()}
#knitr::include_graphics("guided_geo.png")
```




```{r guided-givens-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of splines index using Givens interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()}
#knitr::include_graphics("guided_givens.gif")
```



```{r guided-givens-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of modified splines index using Givens interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()}
#knitr::include_graphics("guided_givens.png")
```

```{r guided-givens-random-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of modified splines index using Givens interpolation with better optimisation.", include=knitr::is_html_output(), eval=knitr::is_html_output()}
#knitr::include_graphics("guided_givens_random.gif")
```



```{r guided-givens-random-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimisation of modified splines index using Givens interpolation with better optimisation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()}
#knitr::include_graphics("guided_givens_random.png")
```


# Conclusion

The R package **woylier** provides implementation of Givens interpolation path algorithm that can be used as an alternative interpolation method for tour. The algorithm implemented in the **woylier** package comes from @buja_cook_asimov_hurley_2005. We illustrate the use of the functions provided in the package for R users.

The motivation to develop this package comes from rotational invariance problem of current geodesic interpolation algorithm implemeneted in \CRANpkg{tourr} package. The package gives users the ability to detect non-linear association between variables more precisely. 

It is important to mention that **woylier** package should be integrated with \CRANpkg{tourr} package. The future improvements that needs to be done in the package is to generalize the interpolation for more than 2d projections of data.
