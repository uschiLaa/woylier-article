# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit woylier-article.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE)


## ----load---------------------------------------------------------------------
library(tourr)
library(tidyverse)
library(woylier)
library(geozoo)
library(ggplot2)
library(patchwork)
library(gganimate)
library(GGally)
library(corrplot)


## ----splines2d-static, out.width = "100%", fig.width = 9, fig.height = 4.5, layout = "l-body", fig.cap="Modified spline index computed on within-plane rotations of the same projection has very different values: (a) original pair has maximum index value of 1.00, (b) axes rotated 45$^o$ drops index value to 0.83, (c) axes rotated 60$^o$ drops index to a very low 0.26. This shows an index that is rotationally variable.", fig.alt = "Three side-by-side scatterplots. The left side plot shows two variables, V5, V6, with a sine curve. The index value is the maximum of 1. The middle plot shows the two variables rotated 45 degrees clock-wise, and the calculated index value is 0.83. The right-side plot is rotated 60 degrees, and the calculated index value is 0.26."----
data("sine_curve")

# modified the splines2d
new_splines2d <- function ()
{
  function(mat) {
    mat <- as.data.frame(mat)
    colnames(mat) <- c("x", "y")
    kx <- ifelse(length(unique(mat$x[!is.na(mat$x)])) < 20,
                 3, 10)
    mgam1 <- mgcv::gam(y ~ s(x, bs = "cr", k = kx), data = mat)
    measure <- 1 - var(residuals(mgam1), na.rm = T)/var(mat$y, na.rm = T)
    return(measure)
  }
}
mat <- data.frame(sine_curve[,5:6])
mat_idx <- round(new_splines2d()(mat), 2)
rot1 <- matrix(c(cos(pi/4), sin(pi/4), 
                -sin(pi/4), cos(pi/4)),
              ncol=2, byrow=T)
mat_rot1 <- data.frame(x = rot1[1,1] * sine_curve$V5 + 
                          rot1[1,2] * sine_curve$V6,
                      y = rot1[2,1] * sine_curve$V5 + 
                           rot1[2,2] * sine_curve$V6)
mat_rot1_idx <- round(new_splines2d()(mat_rot1), 2)
rot2 <- matrix(c(cos(pi/3), sin(pi/3), 
                -sin(pi/3), cos(pi/3)),
              ncol=2, byrow=T)
mat_rot2 <- data.frame(x = rot2[1,1] * sine_curve$V5 + 
                          rot2[1,2] * sine_curve$V6,
                      y = rot2[2,1] * sine_curve$V5 + 
                           rot2[2,2] * sine_curve$V6)
mat_rot2_idx <- round(new_splines2d()(mat_rot2), 2)

p1 <- ggplot(mat, aes(x=V5, y=V6)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=c(1,0), V6=c(0,1)), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=c(1,0), V6=c(0,1), label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("a. 0 deg: ", mat_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p2 <- ggplot(mat_rot1, aes(x=x, y=y)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=rot1[1,], V6=rot1[2,]), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=rot1[1,], V6=rot1[2,], label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("b. 45 deg: ", mat_rot1_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p3 <- ggplot(mat_rot2, aes(x=x, y=y)) + 
  geom_point() + 
  geom_segment(data=tibble(cnt=c(0,0), V5=rot2[1,], V6=rot2[2,]), mapping=aes(x=cnt, xend=V5, y=cnt, yend=V6)) +
  geom_text(data=tibble(V5=rot2[1,], V6=rot2[2,], label=c("V5", "V6")), aes(x=V5, y=V6, label=label)) +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2)) +
  xlab("Proj 1") + ylab("Proj 2") +
  ggtitle(paste("c. 60 deg: ", mat_rot2_idx)) +
  theme_bw() +
  theme(aspect.ratio=1)
p1+p2+p3


## ----dogs, echo=FALSE, out.width="45%", fig.align = "center", fig.show='hold', fig.cap="Plane to plane interpolation (left) and Frame to frame interpolation (right). We used dog index for illustration purposes. For some non-linear index orientation of data could affect the index."----
knitr::include_graphics(
  c("plane.png",
    "frame.png"))


## ----echo=TRUE----------------------------------------------------------------
set.seed(2022)
p <- 6
base1 <- tourr::basis_random(p, d=2)
base2 <- tourr::basis_random(p, d=2)

base1
base2


## ----echo=TRUE----------------------------------------------------------------
givens_full_path(base1, base2, nsteps = 5)


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> set.seed(2022)
#> p <- 6
#> base1 <- tourr::basis_random(p, d=1)
#> base2 <- tourr::basis_random(p, d=1)
#> 
#> frames <- givens_full_path(base1, base2, nsteps = 10)
#> 
#> sp <- generate_space_view(p=p)
#> 
#> sp_path <- add_path(sp, frames)
#> 
#> point1 <- as.data.frame(t(base1))
#> point1$type <- "point1"
#> 
#> point2 <- as.data.frame(t(base2))
#> point2$type <- "point2"
#> 
#> sp_path <- rbind(sp_path, point1, point2)
#> 
#> tourr::render_gif(sp_path[,1:p],
#>                   tour_path = grand_tour(),
#>                   display = display_xy(axes="bottomleft", col=sp_path$type),
#>                   frames = 100,
#>                   "sphere.gif")


## ----1d-path-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 1D projections of 6D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "2 highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."----
#> knitr::include_graphics("sphere.gif")


## ----1d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 1D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of sphere connected by 10 interpolated steps, rotating."----
knitr::include_graphics("sphere_static.png")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> set.seed(2022)
#> p <- 6
#> n <- 1500
#> d <- 2
#> base1 <- tourr::basis_random(p, d=2)
#> base2 <- tourr::basis_random(p, d=2)
#> frames_2d <- givens_full_path(base1, base2, 10)
#> proj_2d <- map(1:n, ~basis_random(n = p,  d=d)) %>%
#>   purrr::flatten_dbl() %>%
#>   matrix(ncol = p*2, byrow = TRUE) %>%
#>   as_tibble()
#> path_2d <- t(apply(frames_2d, 3, c)) %>%
#>   as.data.frame()
#> proj_2d <- proj_2d %>%
#>   mutate(type="torus")
#> path_2d <- path_2d %>%
#>   mutate(type="path")
#> proj_path <- bind_rows(proj_2d, path_2d)
#> 
#> tourr::render_gif(proj_path[,1:6],
#>                   tour_path = grand_tour(),
#>                   display = display_xy(axes="bottomleft", col=proj_path$type),
#>                   frames = 100,
#>                   "torus.gif")


## ----2d-path-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."----
#> 
#> knitr::include_graphics("torus.gif")


## ----2d-path-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Interpolation steps of 2D projections of 6D data", include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.alt = "2 highlighted points on the surface of torus connected by 10 interpolated steps, rotating."----

knitr::include_graphics("torus_static.png")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> # Generate a sample interpolation
#> set.seed(5543)
#> base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
#> base2 <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1), ncol=2, byrow=T)
#> sine_path <- givens_full_path(base1, base2, nsteps=100)
#> sine_all <- NULL
#> sine_proj <- NULL
#> for (i in 1:dim(sine_path)[3]) {
#>   d <- as.matrix(sine_curve) %*% as.matrix(sine_path[,,i])
#>   d <- data.frame(d)
#>   d$idx <- round(tourr::splines2d()(d), 2)
#>   d$frame <- i
#>   sine_all <- bind_rows(sine_all, d)
#>   prj <- as.data.frame(sine_path[,,i])
#>   prj$frame <- i
#>   prj$names <- colnames(sine_curve)
#>   sine_proj <- bind_rows(sine_proj, prj)
#> }
#> sine_label <- sine_all %>%
#>   mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
#> sine_proj <- sine_proj %>%
#>   mutate(cx = 0, cy = 0)
#> # With gganimate
#> 
#> sine_anim <- ggplot() +
#>   geom_segment(data=sine_proj, aes(x=V1, y=V2,
#>                                    xend=cx, yend=cy,
#>                                    group=frame),
#>                colour="grey60") +
#>   geom_text(data=sine_proj, aes(x=V1, y=V2,
#>                                 label=names,
#>                                 group=frame),
#>                colour="grey60") +
#>   geom_point(data=sine_label, aes(x=X1, y=X2)) +
#>   geom_text(data=sine_label, aes(x=labelX, y=labelY,
#>                 label=label_idx), size=10) +
#>   xlab("") + ylab("") +
#>   transition_time(frame) +
#>   theme_void() +
#>   theme(aspect.ratio=1,
#>         plot.background = element_rect(fill=NULL, colour = "black"))
#> 
#> animate(sine_anim, fps=8, renderer = gifski_renderer(loop = TRUE), width=400, height=400)
#> anim_save("sine_anim_givens.gif")


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> library(tourr)
#> set.seed(5541)
#> base1 <- tourr::orthonormalise(tourr::basis_random(6, d=2))
#> base2 <- matrix(c(0,0,0,0,0,0,0,0,1, 0, 0, 1), ncol = 2, byrow = TRUE)
#> basis_set <- array(dim = c(6,2,2))
#> basis_set[,,1] <- base1
#> basis_set[,,2] <- base2
#> attr(basis_set, "class") <- c("history_array", class(basis_set))
#> path_geo <- tourr::interpolate(basis_set, angle = 0.0151)
#> data("sine_curve")
#> 
#> sine_all <- NULL
#> sine_proj <- NULL
#> for (i in 1:dim(path_geo)[3]) {
#>   d <- as.matrix(sine_curve) %*% matrix(c(path_geo[,,i][[1]]), ncol = 2)
#>   d <- data.frame(d)
#>   d$idx <- round(tourr::splines2d()(d), 2)
#>   d$frame <- i
#>   sine_all <- bind_rows(sine_all, d)
#>   prj <- as.data.frame(matrix(c(path_geo[,,i][[1]]), ncol = 2))
#>   prj$frame <- i
#>   prj$names <- colnames(sine_curve)
#>   sine_proj <- bind_rows(sine_proj, prj)
#> }
#> sine_label <- sine_all %>%
#>   mutate(labelX = -1, labelY = 1.45, label_idx = paste0("spl=", format(idx, digits=2)))
#> sine_proj <- sine_proj %>%
#>   mutate(cx = 0, cy = 0)
#> 
#> # With gganimate
#> sine_anim <- ggplot() +
#>   geom_segment(data=sine_proj, aes(x=V1, y=V2,
#>                                    xend=cx, yend=cy,
#>                                    group=frame),
#>                colour="grey60") +
#>   geom_text(data=sine_proj, aes(x=V1, y=V2,
#>                                 label=names,
#>                                 group=frame),
#>                colour="grey60") +
#>   geom_point(data=sine_label, aes(x=X1, y=X2)) +
#>   geom_text(data=sine_label, aes(x=labelX, y=labelY,
#>                 label=label_idx), size=10) +
#>   xlab("") + ylab("") +
#>   transition_time(frame) +
#>   theme_void() +
#>   theme(aspect.ratio=1,
#>         plot.background = element_rect(fill=NULL, colour = "black"))
#> 
#> animate(sine_anim, fps=8, renderer = gifski_renderer(loop = TRUE), width=400, height=400)
#> anim_save("sine_anim_geodesic.gif")


## ----compare-interpolations, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."----
#> knitr::include_graphics(
#>   c("sine_anim_givens.gif",
#>     "sine_anim_geodesic.gif"))


## ----compare-interpolations-static, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_latex_output(), eval=knitr::is_latex_output(), fig.cap="Givens interpolation path (left) and Geodesic interpolation path (right) to target frame. Givens interpolation goes to exact frame that has the correct orientation while Geodesic interpolation goes to rotation of the target plane."----
knitr::include_graphics(
  c("given_sine.png",
    "geodesic_sine.png"))


## ----currency, out.width="100%", fig.width = 9, fig.height = 4.5, layout = "l-body", fig.cap="All the currencies are standardised and the sign is flipped. The high value means the currency strengthened against the USD, and low means that it weakened."----
rates <- read_csv("rates_Nov19_Mar20.csv", show_col_types = FALSE) %>% 
  select(date, ARS, AUD, EUR, JPY, KRW, MYR) 
rates_sub <- rates %>%
  mutate_if(is.numeric, function(x) -1*(x-mean(x))/sd(x))
rates_sub_long <- rates_sub %>% 
  pivot_longer(cols=ARS:MYR, 
               names_to="currency",
               values_to="crossrate") 
ggplot(rates_sub_long, aes(x=date, y=crossrate, colour=currency)) +
  geom_line() +
  scale_colour_brewer("", palette = "Dark2") +
  theme_bw() +
  theme(aspect.ratio = 0.3,
        legend.position = "bottom")
# saving months for coloring in later
rate_march <- lubridate::month(rates$date)==3


## ----pca-result-static, echo=FALSE, out.width="80%", fig.width=8, fig.height=8, fig.align = "center", fig.show='hold', fig.cap="There is a strong non-linear dependence between PC1 and PC2. Observations in March 2020 are highlighted in dark blue, all other months are shown in grey."----
# Use PCA to remove linear dependence
rates_pca <- prcomp(rates[,-1], scale. = TRUE)
pca <- ggscatmat(cbind(tibble::as_tibble(rates_pca$x), rate_march),
                 color = "rate_march") +
  scale_color_manual(values = c("grey", "darkblue")) +
  theme_bw() +
  theme(aspect.ratio = 1,
        legend.position = "none")
pca


## ----pca-result, echo=FALSE, out.width="50%", fig.align = "center", fig.show='hold', include=knitr::is_html_output(), eval=knitr::is_html_output(), fig.cap="There is a strong non-linear dependence between PC1 and PC2."----
#> # Use PCA to remove linear dependence
#> rates_pca <- prcomp(rates[,-1], scale. = TRUE)
#> pca <- ggscatmat(rates_pca$x)
#> pca


## -----------------------------------------------------------------------------
rates_pca_sd <-  apply(rates_pca$x, 2, function(x) (x-mean(x))/sd(x))


## ----echo = FALSE, eval=FALSE-------------------------------------------------
#> # modified the splines2d
#> new_splines2d <- function ()
#> {
#>   function(mat) {
#>     mat <- as.data.frame(mat)
#>     colnames(mat) <- c("x", "y")
#>     kx <- ifelse(length(unique(mat$x[!is.na(mat$x)])) < 20,
#>                  3, 10)
#>     mgam1 <- mgcv::gam(y ~ s(x, bs = "cr", k = kx), data = mat)
#>     measure <- 1 - var(residuals(mgam1), na.rm = T)/var(mat$y, na.rm = T)
#>     return(measure)
#>   }
#> }
#> 
#> col_rates <- rep("grey", nrow(rates))
#> col_rates[rate_march] <- "darkblue"
#> basis_start <- matrix(rep(0, 8), ncol = 2)
#> basis_start[3,1] <- 1
#> basis_start[4,2] <- 1
#> set.seed(2023)
#> record_search_geodesic <- animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
#>             tour_path = guided_tour(new_splines2d(), current = basis_start),
#>             col = col_rates)
#> set.seed(2023)
#> record_search_givens <- animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
#>            tour_path = guided_tour_givens(new_splines2d(),
#>                                           current = basis_start,
#>                                           optim = "search_better",
#>                                           max.tries = 100,
#>                                           alpha = 1),
#>            col = col_rates)
#> set.seed(2023)
#> record_search_better <-animate_pca(rates_pca_sd[,1:4], pc_coefs = rates_pca$rotation[,1:4],
#>            tour_path = guided_tour(new_splines2d(),
#>                                           current = basis_start,
#>                                           search_f = search_better,
#>                                           max.tries = 100,
#>                                           alpha = 1),
#>            col = col_rates)


## ----echo=FALSE, eval=FALSE---------------------------------------------------
#> library(ferrn)
#> get_interp(record_search_geodesic) %>%
#>   ggplot(aes(id, index_val)) +
#>   geom_line() +
#>   geom_point(data = dplyr::bind_rows(get_start(record_search_geodesic),
#>                                      get_interp_last(record_search_geodesic))) +
#>   ylim(0,1)
#> 
#> 
#> get_interp(record_search_better) %>%
#>   ggplot(aes(id, index_val)) +
#>   geom_line() +
#>   geom_point(data = dplyr::bind_rows(get_start(record_search_better),
#>                                      get_interp_last(record_search_better))) +
#>   ylim(0,1)
#> 
#> get_interp(record_search_givens) %>%
#>   ggplot(aes(id, index_val)) +
#>   geom_line() +
#>   geom_point(data = dplyr::bind_rows(get_start(record_search_givens),
#>                                      get_interp_last(record_search_givens))) +
#>   ylim(0,1)


## ----guided-geo-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using geodesic interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> #knitr::include_graphics("guided_geo.gif")


## ----guided-geo-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using geodesic interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
#knitr::include_graphics("guided_geo.png")


## ----guided-givens-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of splines index using Givens interpolation.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> #knitr::include_graphics("guided_givens.gif")


## ----guided-givens-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of modified splines index using Givens interpolation.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
#knitr::include_graphics("guided_givens.png")


## ----guided-givens-random-dynamic, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of modified splines index using Givens interpolation with better optimization.", include=knitr::is_html_output(), eval=knitr::is_html_output()----
#> #knitr::include_graphics("guided_givens_random.gif")


## ----guided-givens-random-static, out.width="50%", fig.align="center", echo = FALSE, fig.height = 3, fig.cap="Guided tour optimization of modified splines index using Givens interpolation with better optimization.", include=knitr::is_latex_output(), eval=knitr::is_latex_output()----
#knitr::include_graphics("guided_givens_random.png")

